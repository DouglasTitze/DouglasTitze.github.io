---
title: Binary Search
date: 2023-03-22 12:00:00 -400
categories: [Daily Questions, Easy]
tags: [python, binary search, array]
---

## Links  

Go to my [solution](#solution)  
Go to the [question](https://leetcode.com/problems/binary-search/){:target="_blank"} on LeetCode  

## My Thoughts  

**What Went Well?**  
I quickly remembered the algorithm and set up the entire solution within 4 minutes.

**What Went Wrong?**  
I spent too much time correcting an almost-complete solution that kept resulting in infinite loops.

**What I Learned?**  
I realize I should have tried reading my code out loud or attempting different solutions when struggling. I also refreshed my memory on a critical algorithm.

**How I Can Improve**  
To prevent similar issues in the future, I need to recognize edge cases that cause infinite loops more easily. I can accomplish this by attempting a solution, even if entirely wrong, instead of just staring at my code. 

**Comments**  
This experience shows that every day won't be perfect, and that's okay. The purpose of my website is not to showcase my flawless problem-solving skills, but to hold myself accountable and continuously improve. By sharing my challenges and reflecting on what went well and what went wrong, I can learn from my mistakes, recognize my strengths, and progress towards my goal.

## Algorithm Description

**Binary Search Algorithm:** A sorting algorithm that repeatedly halves the search interval, until the target varaible is found at the middle index.  

**Visual Examples:**  
Binary search performed on an array that contains the target, [image](https://ds1-iiith.vlabs.ac.in/exp/unsorted-arrays/binary-search/images/binary_search_stepwise.png){:target="_blank"}  
Binary search performed on an array that does **not** contain the target, [image](https://storage.googleapis.com/algodailyrandomassets/tutorials-optimized/binarySearch1.png){:target="_blank"}

## Solution Statistics  

**Time Spent:** 17 minutes  
**Time Complexity:** O(n log n)  
**Space Complexity:** O(1)  

## Solution  

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l = 0               #Left index
        r = len(nums) - 1   #Right index

        while r >= l:       
            m = (l+r)//2    #Middle index = sum both indicies, divide by 2, and floor the result

            if nums[m] == target:
                return m

            if nums[m] < target:
                l = m + 1   #+1 to avoid checking the same value twice and infinite looping
            
            else:
                r = m - 1   #-1 to avoid checking the same value twice and infinite looping

        return -1
```

## Recursive Solution  

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def bin_search(l,r,target):
            if r < l:
                return -1       

            m = (l+r)//2    #Middle index = sum both indicies, divide by 2, and floor the result

            if nums[m] == target:
                return m

            if nums[m] < target:
                return bin_search(m + 1,r,target)   #+1 to avoid checking the same value twice and infinite looping
            
            else:
                return bin_search(l, m - 1,target)   #-1 to avoid checking the same value twice and infinite looping
                

        l = 0               #Left index
        r = len(nums) - 1   #Right index

        return bin_search(l,r,target)
```
