---
title: Coding Question - First Bad Version
date: 2023-03-23 4:30:00 -400
categories: [Coding Questions, Easy, Search Algorithms]
tags: [python, binary search, array]
---

# Links  

Go to my [solution](#optimal-solution)  
Go to the [question](https://leetcode.com/problems/first-bad-version/description/){:target="_blank"} on LeetCode  

# My Thoughts  

**What Went Well**  
I quickly solved created a solution.
Thanks to Thursday's question, I identified the optimal solution while implementing my initial approach.

**What I Learned**  
I, once again, refreshed my memory about the binary search algorithm.

**How I Can Improve**  
The approach I took was the best one I could have.  
Although I knew my first implementation could have been more optimal and, most definitely, easier to understand.  
This approach enabled me to ease into the task and contemplate the optimal solution in the back of my mind while I worked on my initial answer.

**Comments**  
It is essential to be able to solve a problem over finding the most optimal solution.  
Always get somehting on the page and work your way to an answer.  
If you cannot think of the optimal solution in a reasonable amount of time, do the solution you do know how to complete.

# Algorithm Description

**Binary Search Algorithm** A sorting algorithm that repeatedly halves the search interval until the target variable is found at the middle index.
In the implementation I performed, the algorithm has to continuously halve the interval until both the left and right indicies are at the same index.
This is because the question is asking for the very first bad version.
Since there is more than one, we can not be certain that it is the first unless we allow the algorithm to reduce the search interval to one element.  

**Visual Examples**  
Binary search performed on an array that contains the target, [image](https://ds1-iiith.vlabs.ac.in/exp/unsorted-arrays/binary-search/images/binary_search_stepwise.png){:target="_blank"}  
Binary search performed on an array that does **not** contain the target, [image](https://storage.googleapis.com/algodailyrandomassets/tutorials-optimized/binarySearch1.png){:target="_blank"}

# Solution Statistics  

**Time Spent Coding**  
Solution 1: 10 minutes  
Solution 2: 10 minutes

**Time Complexity**  
O(n log n) - Fixed-time complexity due to the question. 
The algorithm halves each iteration's search interval, resulting in the O(n log n) time complexity. 
(Fastest possible time complexity for all search algorithms)  

**Space Complexity**  
O(1) - Only three new variables are created. 
The number of variables declared does not depend on the number of items in the list, resulting in the O(1) space complexity.  

**Runtime Beats**  
90.11% of other submissions  

**Memory Beats**  
49.11% of other sumbissions  

# Optimal Solution  

```python
# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:
        # Left index
        l = 0               
        # Right index
        r = n - 1

        while r >= l:       
            # Middle index = sum both indicies, divide by 2, and floor the result
            m = (l+r)//2

            if isBadVersion(m):
                # -1 to avoid checking the same value twice and infinite looping
                r = m - 1   
            
            else:
                # +1 to avoid checking the same value twice and infinite looping
                l = m + 1  

        # Since the loop exits after the right index is greater than or equal to 'l'
        # 'l' will always hold the first bad version
        return l
```

# Original Solution 
