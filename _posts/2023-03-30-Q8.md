---
title: Coding Question - Middle of the Linked List
date: 2023-03-30 00:00:00 -400
categories: [Coding Questions, Easy]
tags: [python, linked list, two pointer]
---

# Links

Go to my [solution](#solution)  
Go to the [question](https://leetcode.com/problems/middle-of-the-linked-list/){:target="\_blank"} on LeetCode

# My Thoughts  

**What Went Well**  
I solved the problem quickly.

**What I Learned**  
I learned about a new algorithm that I have heard before in passing, but never looked into.

**How I Can Improve**  
I could have looked for a more optimal solution before browsing through other peoples submissions. 
Due to LeetCode's inconsistent statistics I thought my time/space complexity was acceptable.

**Comments**  
I know about the two pointer approach, but did not think of using it in such a way. 
This is a really nice algorithm to learn and is not dificult to remember.

# Algorithm Description

**Fast and Slow Pointer -**  
INCOMPLETE

**Visual Examples**  
Shows how the algorithm can also identify cycles in linked lists, [source](https://emre.me/coding-patterns/fast-slow-pointers/#:~:text=Fast%20%26%20Slow%20Pointers%20Solution,-class%20ListNode%3A%20def&text=slow%20return%20None-,Time%20Complexity%3A%20O(N)%20where%20N%20is%20the%20number,algorithm%20runs%20in%20constant%20space.)  
![image](https://cdn.emre.me/2019-10-23-tortoise-and-hare.gif)

# Solution Statistics  

**Time Spent Coding**  
7 minutes

**Time Complexity**  
O(n) - Each element in the array is only visited once, resulting in the O(n) time complexity.

**Space Complexity**  
O(1) - Only three new variables are created. 
The number of variables declared does not depend on the number of items in the list, resulting in the O(1) space complexity.

**Runtime Beats**  
72.43% of other submissions  

**Memory Beats**  
98.57% of other sumbissions  

# Solution  

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # Negative numbers exist in this data set, so we can not use -infinity
        # We must assign the first element to be the starting point for all variables
        curMin = curMax = globalProd = nums[0]

        for n in nums[1:]:
            # To avoid accidentally multiplying by n twice, we must save the previous 
            # curMax in a variable
            saveMax = curMax

            curMax = max(curMax*n,curMin*n,n)
            curMin = min(saveMax*n,curMin*n,n)

            globalProd = max(curMax,curMin,globalProd)

        return globalProd
```
